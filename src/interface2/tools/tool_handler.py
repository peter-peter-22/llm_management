import json
from typing import Callable, Any, Tuple

from pydantic import BaseModel, ValidationError
from pydantic._internal._model_construction import ModelMetaclass


class Tool:
    def __init__(
            self,
            func: Callable[..., Any],
            name: str,
            description: str | None = None,
            parameters: dict[str, Any] | type[BaseModel] | None = None,
            strict: bool = True,
    ):
        self.name = name
        self.description = description
        self.parameters = parameters
        self.func = func
        self.strict = strict

    def describe_params(self):
        if isinstance(self.parameters, ModelMetaclass):
            return clean_schema(self.parameters.model_json_schema())
        return self.parameters


def describe_tool(tool: Tool):
    tool_definition: dict[str, str | dict[str, Any]] = {
        "type": "function",
        "function": {  # This field different from the OpenAI standard. Ollama doesn't accept that format.
            "name": tool.name,
            "description": tool.description,
            "strict": tool.strict
        }
    }
    if tool.parameters:
        tool_definition["function"]["parameters"] = tool.describe_params()
    return tool_definition


def format_tool_response(tool_name: str, res: str):
    return {
        "role": "tool",
        "tool_name": tool_name,
        "content": res
    }


def format_error_response(tool_name: str, message: str):
    return {
        "role": "tool",
        "tool_name": tool_name,
        "content": json.dumps({
            "ok": False,
            "error": message,
        })
    }


def clean_schema(schema: dict) -> dict:
    """Remove the unnecessary fields from the tool arguments schema generated by pydantic"""

    def strip_keys(obj):
        if isinstance(obj, dict):
            return {
                k: strip_keys(v)
                for k, v in obj.items()
                if k not in {"title"}
            }
        if isinstance(obj, list):
            return [strip_keys(i) for i in obj]
        return obj

    return strip_keys(schema)


class ToolRegistry:
    tools: dict[str, Tool]

    def __init__(self, tools: list[Tool]):
        self.tools = {tool.name: tool for tool in tools}

    def use_tool(self, name: str, args: str | dict[str, Any] | None = None) -> Tuple[Any, bool]:
        # Get the tool
        try:
            tool = self.tools[name]
        except KeyError:
            return f"Unknown tool: {name}", True

        # Parse the args
        args_dict: dict[str, Any] | None = None
        try:
            if args is not None:
                if isinstance(args, str):
                    args_dict = json.loads(args)
                else:
                    args_dict = args
        except json.JSONDecodeError as e:
            return f"Invalid JSON in arguments: {e}", True

        # Call the tool
        try:
            content = tool.func(args_dict)
        # Format tool error
        except ValidationError as e:
            fields: list[Any] = e.errors()
            pretty_fields = [
                {"argument": field["loc"], "message": field["msg"]}
                for field in fields
            ]
            msg = {
                "type": "Invalid argument(s)",
                "errors": pretty_fields,
            }
            return msg, True
        except Exception as e:
            return str(e), True

        # Success response
        return content, False

    def describe_tools(self):
        tool_definitions = []
        for tool in self.tools.values():
            tool_definitions.append(describe_tool(tool))
        print(json.dumps(tool_definitions, indent=2))
        return tool_definitions
